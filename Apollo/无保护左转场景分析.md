# 无保护左转场景分析

![unprotected_left_turn_scenario](E:\PnC\pnc_research\elements\unprotected_left_turn_scenario.png)

如图，该图由apollo9.0：

\apollo-9.0.0\modules\planning\scenarios\traffic_light_unprotected_left_turn\conf\pipeline.pbtxt得到

可以看出，该场景主要由三个阶段，approch、creep、cruise三个stage组成，但是三个阶段里面执行的task基本一致。接下来先分析相关task。

## Lane Follow Path

该模块主要过程为处理以下四个函数

```C++
  //获取当前起点的sl位置
  GetStartPointSLState();
  //获取不同reference_line的候选boundaries
  if (!DecidePathBounds(&candidate_path_boundaries)) {
    AERROR << "Decide path bound failed";
    return Status::OK();
  }
  //利用osqp对reference_line进行优化
  if (!OptimizePath(candidate_path_boundaries, &candidate_path_data)) {
    AERROR << "Optmize path failed";
    return Status::OK();
  }
  //检测目标路径是否可用
  if (!AssessPath(&candidate_path_data,
                  reference_line_info->mutable_path_data())) {
    AERROR << "Path assessment failed";
  }
```

## Lane Borrow Path

```C++
apollo::common::Status LaneBorrowPath::Process(
    Frame* frame, ReferenceLineInfo* reference_line_info) {
   //检测是否运行借道
  if (!config_.is_allow_lane_borrowing() ||
      reference_line_info->path_reusable()) {
    ADEBUG << "path reusable" << reference_line_info->path_reusable()
           << ",skip";
    return Status::OK();
  }
    //是否有必要借道行驶
  if (!IsNecessaryToBorrowLane()) {
    ADEBUG << "No need to borrow lane";
    return Status::OK();
  }
  std::vector<PathBoundary> candidate_path_boundaries;
  std::vector<PathData> candidate_path_data;
	//下面和Lane Follow类似
  GetStartPointSLState();
  if (!DecidePathBounds(&candidate_path_boundaries)) {
    return Status::OK();
  }
  if (!OptimizePath(candidate_path_boundaries, &candidate_path_data)) {
    return Status::OK();
  }
  if (AssessPath(&candidate_path_data,
                 reference_line_info->mutable_path_data())) {
    ADEBUG << "lane borrow path success";
  }

  return Status::OK();
}
```

Lane Borrow Path与Lane Follow区别在于，会检测是否有必要借道行驶，如有必要的话，DecidePathBounds会选择对目标车道进行Bounds选取。

```C++
void LaneBorrowPath::UpdateSelfPathInfo() {
  auto cur_path = reference_line_info_->path_data();
  //当前道路非空，且当前道路无障碍物，use_self_lane_加一
  if (!cur_path.Empty() &&
      cur_path.path_label().find("self") != std::string::npos &&
      cur_path.blocking_obstacle_id().empty()) {
    use_self_lane_ = std::min(use_self_lane_ + 1, 10);
  } else {
    use_self_lane_ = 0;
  }
  blocking_obstacle_id_ = cur_path.blocking_obstacle_id();
}

bool LaneBorrowPath::IsNecessaryToBorrowLane() {
  auto* mutable_path_decider_status = injector_->planning_context()
                                          ->mutable_planning_status()
                                          ->mutable_path_decider();
  //1、如果当前处于bane borrow场景那么
  if (mutable_path_decider_status->is_in_path_lane_borrow_scenario()) {
   	//1.1 f path进行计数，这里应该是标记借道次数，好确定何时返回自车道。
    UpdateSelfPathInfo();
    //1.2 如果次数大于6
    // If originally borrowing neighbor lane:
    if (use_self_lane_ >= 6) {
      // If have been able to use self-lane for some time, then switch to
      // non-lane-borrowing.
      //将借道场景关闭
      mutable_path_decider_status->set_is_in_path_lane_borrow_scenario(false);
      decided_side_pass_direction_.clear();
      AINFO << "Switch from LANE-BORROW path to SELF-LANE path.";
    }
  } else {
    //2、如果不处于lane borrow场景的话，判断是否需要lane borrow
    //originally not borrowing neighbor lane:
    AINFO << "Blocking obstacle ID["
          << mutable_path_decider_status->front_static_obstacle_id() << "]";
    // ADC requirements check for lane-borrowing:
    //2.1 如果只有一条reference line那么返回
    if (!HasSingleReferenceLine(*frame_)) {
      return false;
    }
    //2.2 如果当前车速在side pass允许的车速内
    if (!IsWithinSidePassingSpeedADC(*frame_)) {
      return false;
    }
	//2.3 对障碍物进行检测判断是否有必要借道
    // Obstacle condition check for lane-borrowing:
    //2.3.1 该阻塞障碍物是否远离路口
    if (!IsBlockingObstacleFarFromIntersection(*reference_line_info_)) {
      return false;
    }
    //2.3.2 障碍物是否长时间阻塞
    if (!IsLongTermBlockingObstacle()) {
      return false;
    }
    //2.3.3 阻塞障碍物是否在目的地附近
    if (!IsBlockingObstacleWithinDestination(*reference_line_info_)) {
      return false;
    }
    //2.3.4 是否能绕行过障碍物
    if (!IsSidePassableObstacle(*reference_line_info_)) {
      return false;
    }
    //2.4 选择进行借道
    // switch to lane-borrowing
    if (decided_side_pass_direction_.empty()) {
      // first time init decided_side_pass_direction
      bool left_borrowable;
      bool right_borrowable;
      //应该从左侧还是右侧进行借道
      CheckLaneBorrow(*reference_line_info_, &left_borrowable,
                      &right_borrowable);
      if (!left_borrowable && !right_borrowable) {
        //无法借道
        mutable_path_decider_status->set_is_in_path_lane_borrow_scenario(false);
        AINFO << "LEFT AND RIGHT LANE CAN NOT BORROW";
        return false;
      } else {
        //将场景设置为lane borrow
        mutable_path_decider_status->set_is_in_path_lane_borrow_scenario(true);
        if (left_borrowable) {
          decided_side_pass_direction_.push_back(
              SidePassDirection::LEFT_BORROW);
        }
        if (right_borrowable) {
          decided_side_pass_direction_.push_back(
              SidePassDirection::RIGHT_BORROW);
        }
      }
    }
    use_self_lane_ = 0;
    AINFO << "Switch from SELF-LANE path to LANE-BORROW path.";
  }
  return mutable_path_decider_status->is_in_path_lane_borrow_scenario();
}
```

## Fallback Path

该模块功能主要是用于生成变道时的备用路径，具体工作方式与lane follow类似，不详细展开。

## Path Decider

Path模块主要工作是对静态障碍物进行处理，判断是忽略、stop或是nudge

```C++
bool PathDecider::MakeStaticObstacleDecision(
    const PathData &path_data, const std::string &blocking_obstacle_id,
    PathDecision *const path_decision) {
  // Sanity checks and get important values.
  ACHECK(path_decision);
  const auto &frenet_path = path_data.frenet_frame_path();
  if (frenet_path.empty()) {
    AERROR << "Path is empty.";
    return false;
  }
  const double half_width =
      common::VehicleConfigHelper::GetConfig().vehicle_param().width() / 2.0;
  const double lateral_radius = half_width + FLAGS_lateral_ignore_buffer;

  // Go through every obstacle and make decisions.
  // 1. 对path decision中的每一个obstacle进行处理
  for (const auto *obstacle : path_decision->obstacles().Items()) {
    const std::string &obstacle_id = obstacle->Id();
    const std::string obstacle_type_name =
        PerceptionObstacle_Type_Name(obstacle->Perception().type());
    ADEBUG << "obstacle_id[<< " << obstacle_id << "] type["
           << obstacle_type_name << "]";
    // 1.1如果该obstacle不是静态的或者是虚拟的，则跳过
    if (!obstacle->IsStatic() || obstacle->IsVirtual()) {
      continue;
    }
    // 1.2也就是说这里主要对静态障碍物进行处理
    //  - skip decision making for obstacles with IGNORE/STOP decisions already.
    // 2. 如果障碍物有纵向决策且是忽略同时横向决策也是忽略，则跳过
    if (obstacle->HasLongitudinalDecision() &&
        obstacle->LongitudinalDecision().has_ignore() &&
        obstacle->HasLateralDecision() &&
        obstacle->LateralDecision().has_ignore()) {
      continue;
    }
    // 3. 如果有纵向决策且为stop，那么到后面的stop
    // decision模块进行处理，这里跳过
    if (obstacle->HasLongitudinalDecision() &&
        obstacle->LongitudinalDecision().has_stop()) {
      // STOP decision
      continue;
    }
    // - add STOP decision for blocking obstacles.
    // 4. 对阻塞类型的障碍物增加Stop decision
    // 4.1 如果id为阻塞障碍物id且不处于lane borrow场景
    if (obstacle->Id() == blocking_obstacle_id &&
        !injector_->planning_context()
             ->planning_status()
             .path_decider()
             .is_in_path_lane_borrow_scenario()) {
      // Add stop decision
      // 4.2 对该障碍物添加stop决策
      ADEBUG << "Blocking obstacle = " << blocking_obstacle_id;
      ObjectDecisionType object_decision;
      *object_decision.mutable_stop() = GenerateObjectStopDecision(*obstacle);
      path_decision->AddLongitudinalDecision("PathDecider/blocking_obstacle",
                                             obstacle->Id(), object_decision);
      continue;
    }
    // - skip decision making for clear-zone obstacles.
    // 5. 跳过对clear-zone类型的障碍物进行决策
    if (obstacle->reference_line_st_boundary().boundary_type() ==
        STBoundary::BoundaryType::KEEP_CLEAR) {
      continue;
    }

    // 0. IGNORE by default and if obstacle is not in path s at all.
    // 6. 如果obstacle一点也在path，忽略该障碍物且方式为default
    ObjectDecisionType object_decision;
    object_decision.mutable_ignore();
    const auto &sl_boundary = obstacle->PerceptionSLBoundary();
    if (sl_boundary.end_s() < frenet_path.front().s() ||
        sl_boundary.start_s() > frenet_path.back().s()) {
      path_decision->AddLongitudinalDecision("PathDecider/not-in-s",
                                             obstacle->Id(), object_decision);
      path_decision->AddLateralDecision("PathDecider/not-in-s", obstacle->Id(),
                                        object_decision);
      continue;
    }
    // 7. 获取该障碍物在frenet path上最进行的点
    const auto frenet_point = frenet_path.GetNearestPoint(sl_boundary);
    const double curr_l = frenet_point.l();
    /// 8. 计算最小的nudge距离
    double min_nudge_l = half_width + config_.static_obstacle_buffer() / 2.0;
    // 9. 判断横向距离
    // 9.1 如果横向上离得很远，则忽略掉
    if (curr_l - lateral_radius > sl_boundary.end_l() ||
        curr_l + lateral_radius < sl_boundary.start_l()) {
      // 1. IGNORE if laterally too far away.
      path_decision->AddLateralDecision("PathDecider/not-in-l", obstacle->Id(),
                                        object_decision);
    } else if (sl_boundary.end_l() >= curr_l - min_nudge_l &&
               sl_boundary.start_l() <= curr_l + min_nudge_l) {
      // 9.1 如果横向上存在重合部分，则加入stop决策
      // 2. STOP if laterally too overlapping.
      *object_decision.mutable_stop() = GenerateObjectStopDecision(*obstacle);
      // 9.1.1 纵向决策添加该障碍物的stop决策
      if (path_decision->MergeWithMainStop(
              object_decision.stop(), obstacle->Id(),
              reference_line_info_->reference_line(),
              reference_line_info_->AdcSlBoundary())) {
        // 判断该stop与main stop直接相对关系
        path_decision->AddLongitudinalDecision("PathDecider/nearest-stop",
                                               obstacle->Id(), object_decision);
      } else {
        ObjectDecisionType object_decision;
        object_decision.mutable_ignore();
        path_decision->AddLongitudinalDecision("PathDecider/not-nearest-stop",
                                               obstacle->Id(), object_decision);
      }
      AINFO << "Add stop decision for static obs " << obstacle->Id()
            << "start l" << sl_boundary.start_l() << "end l"
            << sl_boundary.end_l() << "curr_l" << curr_l << "min_nudge_l"
            << min_nudge_l;
    } else {
      // 3. NUDGE if laterally very close.
      // 9.2 如果横向上并不重合，只不过离得较近
      if (sl_boundary.end_l() < curr_l - min_nudge_l) {  // &&
        // sl_boundary.end_l() > curr_l - min_nudge_l - 0.3) {
        // LEFT_NUDGE
        // 9.2.1 从左侧nudeg
        ObjectNudge *object_nudge_ptr = object_decision.mutable_nudge();
        object_nudge_ptr->set_type(ObjectNudge::LEFT_NUDGE);
        object_nudge_ptr->set_distance_l(config_.static_obstacle_buffer());
        path_decision->AddLateralDecision("PathDecider/left-nudge",
                                          obstacle->Id(), object_decision);
      } else if (sl_boundary.start_l() > curr_l + min_nudge_l) {  // &&
        // sl_boundary.start_l() < curr_l + min_nudge_l + 0.3) {
        // RIGHT_NUDGE
        // 9.2.2 从右侧nudge
        ObjectNudge *object_nudge_ptr = object_decision.mutable_nudge();
        object_nudge_ptr->set_type(ObjectNudge::RIGHT_NUDGE);
        object_nudge_ptr->set_distance_l(-config_.static_obstacle_buffer());
        path_decision->AddLateralDecision("PathDecider/right-nudge",
                                          obstacle->Id(), object_decision);
      }
    }
  }

  return true;
}
```

## Rule Based Stop Decider

![apollo_rule_based_decider](E:\PnC\pnc_research\elements\apollo_rule_based_decider.png)

![apollo_rule_based_decider_side_pass](E:\PnC\pnc_research\elements\apollo_rule_based_decider_side_pass.png)

![apollo_rule_based_decider_urgency](E:\PnC\pnc_research\elements\apollo_rule_based_decider_urgency.png)

## St Bounds Decider

![apllo_st_bounds_decider](E:\PnC\pnc_research\elements\apllo_st_bounds_decider.png)
